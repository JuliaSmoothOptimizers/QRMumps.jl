var documenterSearchIndex = {"docs":
[{"location":"tutorials/spd/","page":"Symmetric and positive definite linear systems","title":"Symmetric and positive definite linear systems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 1, 2, 3, 3, 4, 4, 5]\njcn = [1, 3, 4, 5, 2, 3, 5, 4, 5, 5]\nval = [53.0, 8.0, 4.0, 3.0, 10.0, 6.0, 8.0, 26.0, 5.0, 14.0]\n\nA = Symmetric(sparse(irn, jcn, val, 5, 5), :U)\nb = [108.0, 20.0, 66.0, 133.0, 117.0]\nx_star = [1.0, 2.0, 3.0, 4.0, 5.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nx = qrm_spposv(spmat, b)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/spd/","page":"Symmetric and positive definite linear systems","title":"Symmetric and positive definite linear systems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5]\njcn = [1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5]\nval = [4.0, 1.0, 1.0, 4.0, 1.0, 1.0, 4.0, 1.0, 1.0, 4.0, 1.0, 1.0, 4.0]\n\nA = sparse(irn, jcn, val, 5, 5)\nA_L = tril(A)\nb = [5.0, 6.0, 6.0, 6.0, 5.0]\nx_star = [1.0, 1.0, 1.0, 1.0, 1.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A_L, sym=true)\nx = qrm_spposv(spmat, b)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/spd/","page":"Symmetric and positive definite linear systems","title":"Symmetric and positive definite linear systems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 3, 4, 5, 2, 3, 5, 4, 5, 5]\njcn = [1, 1, 1, 1, 2, 3, 3, 4, 4, 5]\nval = [53.0, 8.0, 4.0, 3.0, 10.0, 6.0, 8.0, 26.0, 5.0, 14.0]\n\nA = Symmetric(sparse(irn, jcn, val, 5, 5), :L)\nb = [108.0, 20.0, 66.0, 133.0, 117.0]\nx_star = [1.0, 2.0, 3.0, 4.0, 5.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct)\nqrm_factorize!(spmat, spfct)\nz = qrm_solve(spfct, b, transp='t')\nx = qrm_solve(spfct, z)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/spd/","page":"Symmetric and positive definite linear systems","title":"Symmetric and positive definite linear systems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5]\njcn = [1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5]\nval = [4.0, 1.0, 1.0, 4.0, 1.0, 1.0, 4.0, 1.0, 1.0, 4.0, 1.0, 1.0, 4.0]\n\nA = sparse(irn, jcn, val, 5, 5)\nA_U = triu(A)\nb = [5.0, 6.0, 6.0, 6.0, 5.0]\nx_star = [1.0, 1.0, 1.0, 1.0, 1.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A_U, sym=true)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct)\nqrm_factorize!(spmat, spfct)\nz = qrm_solve(spfct, b, transp='t')\nx = qrm_solve(spfct, z)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/spd/","page":"Symmetric and positive definite linear systems","title":"Symmetric and positive definite linear systems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 2, 2, 3, 3, 3]\njcn = [1, 1, 2, 1, 2, 3]\nval = [7.0, -im, 8.0, 5im, 5.0, 10.0]\n\nA = Hermitian(sparse(irn, jcn, val, 3, 3), :L)\nb = [11.0-6im, 32.0+12im, 35.0+20im]\nx_star = [1.0+im, 2.0+im, 3.0+im]\nx = copy(b)\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct)\nqrm_factorize!(spmat, spfct)\n\nqrm_solve!(spfct, x, x, transp='c')\nqrm_solve!(spfct, x, x)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/spd/","page":"Symmetric and positive definite linear systems","title":"Symmetric and positive definite linear systems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 2, 2, 3]\njcn = [1, 2, 3, 2, 3, 3]\nval = [7.0, im, -5im, 8.0, 5.0, 10.0]\n\nA = Hermitian(sparse(irn, jcn, val, 3, 3), :U)\nb = [11.0-6im, 32.0+12im, 35.0+20im]\nx_star = [1.0+im, 2.0+im, 3.0+im]\nx = copy(b)\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct)\nqrm_factorize!(spmat, spfct)\n\nqrm_solve!(spfct, x, x, transp='c')\nqrm_solve!(spfct, x, x)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/ls/","page":"Least-squares problems","title":"Least-squares problems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6, 7, 7]\njcn = [1, 3, 5, 2, 3, 5, 1, 4, 4, 5, 2, 1, 3]\nval = [1.0, 2.0, 3.0, 1.0, 1.0, 2.0, 4.0, 1.0, 5.0, 1.0, 3.0, 6.0, 1.0]\n\nA = sparse(irn, jcn, val, 7, 5)\nb = [22.0, 5.0, 13.0, 8.0, 25.0, 5.0, 9.0]\nx_star = [1.0, 2.0, 3.0, 4.0, 5.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nx = qrm_least_squares(spmat, b)\n\nerror_norm = norm(x - x_star)\nr = A * x - b\noptimality_residual_norm = norm(A' * r)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Optimality residual norm ‖Aᵀr‖ = %10.5e\\n\", optimality_residual_norm)","category":"page"},{"location":"tutorials/ls/","page":"Least-squares problems","title":"Least-squares problems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6, 7, 7]\njcn = [1, 3, 5, 2, 3, 5, 1, 4, 4, 5, 2, 1, 3]\nval = [1.0, 2.0, 3.0, 1.0, 1.0, 2.0, 4.0, 1.0, 5.0, 1.0, 3.0, 6.0, 1.0]\n\nA = sparse(irn, jcn, val, 7, 5)\nb = [22.0, 5.0, 13.0, 8.0, 25.0, 5.0, 9.0]\nx_star = [1.0, 2.0, 3.0, 4.0, 5.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct)\nqrm_factorize!(spmat, spfct)\nz = qrm_apply(spfct, b, transp='t')\nx = qrm_solve(spfct, z)\n\nerror_norm = norm(x - x_star)\nr = A * x - b\noptimality_residual_norm = norm(A' * r)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Optimality residual norm ‖Aᵀr‖ = %10.5e\\n\", optimality_residual_norm)","category":"page"},{"location":"tutorials/ls/","page":"Least-squares problems","title":"Least-squares problems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6, 7, 7]\njcn = [1, 3, 5, 2, 3, 5, 1, 4, 4, 5, 2, 1, 3]\nval = [1.0+im, 2.0-im, 3.0+im, 1.0-im, 1.0+im, 2.0-im, 4.0+im, 1.0-im, 5.0+im, 1.0-im, 3.0+im, 6.0-im, 1.0+im]\n\nA = sparse(irn, jcn, val, 7, 5)\nb = [1.0+im, 2.0+im, 3.0+im, 4.0+im, 5.0+im, 6.0+im, 7.0+im]\nz = copy(b)\nx = zeros(ComplexF64, 5)\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct)\nqrm_factorize!(spmat, spfct)\nqrm_apply!(spfct, z, transp='c')\nqrm_solve!(spfct, z, x)\n\nr = A * x - b\noptimality_residual_norm = norm(A' * r)\n\n@printf(\"Optimality residual norm ‖Aᵀr‖ = %10.5e\\n\", optimality_residual_norm)","category":"page"},{"location":"performance/#Performance-tuning","page":"Performance tuning","title":"Performance tuning","text":"","category":"section"},{"location":"performance/","page":"Performance tuning","title":"Performance tuning","text":"The performance of qr_mumps depends on a number of parameters. Default values are provided for these parameters that are expected to achieve reasonably good performance on a wide range of problems and architectures but for optimal performance these should be tuned. In this section we provide a list of these parameters and explain how do they have an effect on performance.","category":"page"},{"location":"performance/#**Block-size**","page":"Performance tuning","title":"Block size","text":"","category":"section"},{"location":"performance/","page":"Performance tuning","title":"Performance tuning","text":"qr_mumps decomposes frontal matrices into blocks of size mb × mb (set through the qrm_mb control parameter); this decomposition provides an additional level of parallelism (other than that already expressed by the elimination tree) because it is possible to execute concurrently tasks that operate on different blocks. On the one hand, small values of mb provide high parallelism; on the other hand, high values of mb provide high efficiency for each task and make the tasks scheduling overhead negligible. This parameter should be, therefore, chosen as to provide the best compromise between parallelism and tasks efficiency. The optimal value depends on the size and structure of the problem, the number and features of processing units, the efficiency and scalability of BLAS operations, etc... On current CPUs block sizes of 128 or 256 achieve close to optimal task performance and good parallelism on moderately sized problems; if GPUs are used, higher block sizes (1024) provide better performance. Choosing a large mb value to achieve high performance on GPU devices can severely reduce parallelism and lead to CPU starvation. In this case the nb parameter (qrm_nb) can be used to generate additional parallelism; if this parameter is set to a submultiple of mb, the dynamic, hierarchical partitioning technique is used which can lead to better performance. Finally, some tasks use an internal block size; this is set by the ib parameter (qrm_ib which has to be a submultiple of mb and nb) and defines a compromise between efficiency of tasks and overall amount of floating point operations. Again, when GPUs are used, larger values of ib lead to better speed whereas on CPUs values of 32/64 provide satisfactory speed.","category":"page"},{"location":"performance/#**Reduction-tree-shape**","page":"Performance tuning","title":"Reduction tree shape","text":"","category":"section"},{"location":"performance/","page":"Performance tuning","title":"Performance tuning","text":"The bh parameter (qrm_bh) defines the shape of the reduction tree in the QR panel reduction. A value of k means that a panel is divided in groups of size k, intra-group reduction is done with a flat tree, inter-group reduction with a binary tree. Therefore, a value of one achieves the highest parallelism because the whole panel is reduced through a binary tree. Conversely a value which is equal or higher than the number of blocks in a panel leads to lower parallelism because all the blocks in the panels are reduced one after the other; a zero or negative value sets a flat tree on all panels in all fronts of the multifrontal factorization. Nevertheless it must be noted that excessively small values of bh may lead to inefficient computations because of the nature of the involved tasks. A flat tree typically achieves high performance on a wide range of problems but for very overdetermined problems it may be beneficial to use hybrid trees.","category":"page"},{"location":"performance/#**Ordering**","page":"Performance tuning","title":"Ordering","text":"","category":"section"},{"location":"performance/","page":"Performance tuning","title":"Performance tuning","text":"Fill-reducing ordering is essential to limit the fill-in produced by the factorization. This ordering (set through the qrm_ordering control parameter) is computed during the analysis phase and corresponds to a matrix permutation that defines the order in which unknowns are eliminated. The ordering will also affect the shape of the elimination tree which can be more or less balanced or deep with obvious consequences on parallelism, efficiency and, ultimately, execution time. Nested Dissection methods, such as those implemented in the Metis and SCOTCH packages, usually provide the best results and their running time may be high; local orderings such as AMD/COLAMD typically have a lower running time, which results in a faster analysis step, but lead to higher fill-in and thus higher running time and memory consumption for the factorization and the solve.","category":"page"},{"location":"information_parameters/#Information-parameters","page":"Information parameters","title":"Information parameters","text":"","category":"section"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"Information parameters return information about the behavior of qr_mumps and can be either global or problem specific. All the information parameters can be gotten through the qrm_get routine; problem specific control parameters can also be retrieved by manually reading the gstats attribute of a qrm_spfct factorization. The qrm_get routine can also be used to retrieve the values of all the control parameters described in the previous section with the obvious usage. The type of all information parameters is Int64.","category":"page"},{"location":"information_parameters/#Global-parameters","page":"Information parameters","title":"Global parameters","text":"","category":"section"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_max_mem: this parameter returns the maximum amount of memory allocated by qr_mumps during its execution.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_tot_mem: this parameter returns the total amount of memory allocated by qr_mumps at the moment when the qrm_get routine is called.","category":"page"},{"location":"information_parameters/#Problem-specific-parameters","page":"Information parameters","title":"Problem specific parameters","text":"","category":"section"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_e_facto_flops: this parameter returns an estimate, computed during the analysis phase, of the number of floating point operations performed during the factorization phase. This value is only available after the qrm_analyse routine is executed.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_facto_flops: this parameter returns the number of floating point operations performed during the factorization phase. This value is only available after the qrm_analyse routine is executed.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_e_nnz_r: this parameter returns an estimate, computed during the analysis phase, of the number of nonzero coefficients in the R factor. This value is only available after the qrm_analyse routine is executed.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_nnz_r: this parameter returns the actual number of the nonzero coefficients in the R factor after the factorization is done. This value is only available after the qrm_factorize routine is executed.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_e_nnz_h: this parameter returns an estimate, computed during the analysis phase, of the number of nonzero coefficients in the Q matrix. This value is only available after the qrm_analyse routine is executed.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_nnz_h: this parameter returns the actual number of the nonzero coefficients in the Q matrix after the factorization is done. This value is only available after the qrm_factorize routine is executed.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_e_facto_mempeak: this parameter returns an estimate of the peak memory consumption of the factorization operation.","category":"page"},{"location":"information_parameters/","page":"Information parameters","title":"Information parameters","text":"qrm_rd_num: this information parameter returns the number of diagonal coefficients of the R factor whose absolute value is lower than qrm_rd_eps if this control parameter was set to a value greater than 0.","category":"page"},{"location":"features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/#**Types-of-problems**","page":"Features","title":"Types of problems","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"qr_mumps can handle unsymmetric and symmetric, positive definite problems. In the first case it will use a QR factorization whereas, in the second, it will use a Cholesky factorization. In order to choose one or the other method, qr_mumps must be informed about the type of the problem through the sym argument of the qrm_spmat_init function: false means that the problem is unsymmetric and true means symmetric, positive definite. Note that in the second case, only half of the matrix must be provided, i.e., if the coefficient (i, j) is provided (j, i) must not be given.","category":"page"},{"location":"features/#**Memory-consumption-control**","page":"Features","title":"Memory consumption control","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"qr_mumps allows for controlling the amount of memory used in the parallel factorization stage. In the multifrontal method, the memory consumption varies greatly throughout the sequential factorization reaching a maximum value which is referred to as the sequential peak (sp). Parallelism can considerably increase this peak because, in order to feed the working threads, more data is allocated at the same time which results in higher concurrency. In qr_mumps it is possible to bound the memory consumption of the factorization phase through the qrm_mem_relax parameter. If this parameter is set to a real value x ≥ 1, the memory consumption will be bounded by x × sp. Clearly, the tighter is this upper bound, the slower the factorization will proceed. Note that sp only includes the memory consumed by the factorization operation; moreover, although in practice it is possible to precisely pre-compute this value in the analysis phase, this may be expensive and thus qrm_analyse only computes a (hopefully) slight overestimation. The value of sp is available upon completion of the analysis phase through the qrm_e_facto_mempeak information parameter.","category":"page"},{"location":"features/#**Fill-reducing-permutations**","page":"Features","title":"Fill-reducing permutations","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"qr_mumps supports multiple methods for reducing the factorization fill-in through matrix column permutations. The choice is controlled through the qrm_ordering control parameter. Nested-dissection based methods are available through the packages Metis and SCOTCH packages as well as average minimum degree through the COLAMD one. Nested-dissection based methods usually lead to lower fill-in which ultimately results in faster and less memory consuming factorization. COLAMD, instead, typically leads to a faster execution of the analysis phase although is not as effective in reducing the fill-in which may result in a slower and more memory consuming factorization. Because the overall execution time is commonly dominated by the factorization, nested-dissection methods are usually more effective especially for large size problems. qr_mumps also allows the user to provide their own permutation.","category":"page"},{"location":"control_parameters/#Control-parameters","page":"Control parameters","title":"Control parameters","text":"","category":"section"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"Control parameters define the behavior of qr_mumps and can be set in two modes:","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"global mode: in this mode it possible to either set generic parameters (e.g., the unit for output or error messages) or default parameter values (e.g., the ordering method to be used on the problem) that apply to all initialized qrm_spfct factorizations.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"problem mode: these parameters control the behavior of qr_mumps on a specific sparse factorization problem. Because the qrm_spfct_init routine sets the control parameters to their default values, these have to be modified after the sparse factorization object initialization.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"All the control parameters can be set through the qrm_set routine.","category":"page"},{"location":"control_parameters/#Global-parameters","page":"Control parameters","title":"Global parameters","text":"","category":"section"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_ncpu: integer specifying the number of CPU cores to use for the subsequent qr_mumps calls. It is an argument to the qrm_init routine. Default is 1.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_ounit: integer specifying the unit for output messages; if negative, output messages are suppressed. Default is 6 (stdout).","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_eunit: an integer specifying the unit for error messages; if negative, error messages are suppressed. Default is 0.","category":"page"},{"location":"control_parameters/#Problem-specific-parameters","page":"Control parameters","title":"Problem specific parameters","text":"","category":"section"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_ordering: this parameter specifies what permutation to apply to the columns of the input matrix in order to reduce the fill-in and, consequently, the operation count of the factorization and solve phases. This parameter is used by qr_mumps during the analysis phase and, therefore, has to be set before it starts. The following pre-defined values are accepted:\nqrm_auto (0) : the choice is automatically made by qr_mumps. This is the default.\nqrm_natural (1) : no permutation is applied.\nqrm_given (2) : a column permutation is provided by the user through the cperm_in attribute of a qrm_spfct factorization.\nqrm_colamd (3) : the COLAMD software package (if installed) is used for computing the column permutation.\nqrm_metis (4) : the Metis software package (if installed) is used for computing the column permutation.\nqrm_scotch (5) : the SCOTCH software package (if installed) is used for computing the column permutation.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_keeph: this parameter says whether the Q matrix should be kept for later use or discarded. This parameter is used by qr_mumps during the factorization phase and, therefore, has to be set before it starts. Accepted value are:\nqrm_yes (1) : the Q matrix is kept. This is the default.\nqrm_no (0) : the Q matrix is discarded.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_mb and qrm_nb: These parameters define the block-size (rows and columns, respectively) for data partitioning and, thus, granularity of parallel tasks. Smaller values mean higher concurrence. This parameter, however, implicitly defines an upper bound for the granularity of call to BLAS and LAPACK routines (defined by the qrm_ib parameter described below); therefore, excessively small values may result in poor performance. This parameter is used by qr_mumps during the analysis and factorization phases and, therefore, has to be set before these start. The default value is 256 for both. Note that qrm_mb has to be a multiple of qrm_nb.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_ib: this parameter defines the granularity of BLAS/LAPACK operations. Larger values mean better efficiency but imply more fill-in and thus more flops and memory consumption. The value of this parameter is upper-bounded by the qrm_nb parameter described above. This parameter is used by qr_mumps during the factorization phase and, therefore, has to be set before it starts. The default value is 32. It is strongly advised to choose, for this parameter, a submultiple of qrm_nb.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_bh: this parameter defines the type of algorithm for the communication-avoiding QR factorization of frontal matrices. Smaller values mean more concurrency but worse tasks efficiency; if lower or equal to zero the largest possible value is chosen for each front. Default value is -1.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_rhsnb: in the case where multiple right-hand sides are passed to the qrm_apply or the qrm_solve routines, this parameter can be used to define a blocking of the right-hand sides. This parameter is used by qr_mumps during the solve phase and, therefore, has to be set before it starts. By default, all the right-hand sides are treated in a single block.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_mem_relax: a value (≥ 1) that sets a relaxation parameter, with respect to the sequential peak, for the memory consumption in the factorization phase. If negative, the memory consumption is not bounded. Default value is −1.0.","category":"page"},{"location":"control_parameters/","page":"Control parameters","title":"Control parameters","text":"qrm_rd_eps: a value setting a threshold to estimate the rank of the problem. If > 0 the qrm_factorize routine will count the number of diagonal coefficients of the R factor whose absolute value is smaller than the provided value. This number can be retrieved through the qrm_rd_num information parameter described in the next section.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"qrm_spmat\nqrm_spfct","category":"page"},{"location":"api/#QRMumps.qrm_spmat","page":"API","title":"QRMumps.qrm_spmat","text":"This data type is used to store a sparse matrix in the COO (or coordinate) format through the irn, jcn and val fields containing the row indices, column indices and values, respectively and the m, n and nz containing the number of rows, columns and nonzeros, respectively. qr_mumps uses a Fortran-style 1-based numbering and thus all row indices are expected to be between 1 and m and all the column indices between 1 and n. Duplicate entries are summed during the factorization, out-of-bound entries are ignored. The sym field is used to specify if the matrix is symmetric and positive definite (true) or not (false).\n\n\n\n\n\n","category":"type"},{"location":"api/#QRMumps.qrm_spfct","page":"API","title":"QRMumps.qrm_spfct","text":"This type is used to set the parameters that control the behavior of a sparse factorization, to collect information about its execution (number of flops, memory consumpnion etc) and store the result of  the factorization, namely, the factors with all the symbolic information needed to use them in the solve phase.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"qrm_init\nqrm_finalize","category":"page"},{"location":"api/#QRMumps.qrm_init","page":"API","title":"QRMumps.qrm_init","text":"qrm_init(ncpu, ngpu)\n\nThis routine initializes qr_mumps and should be called prior to any other qr_mumps routine. This function is automatically called if you use qr_mumps precompiled with Yggdrasil.\n\nqrm_init()\n\nncpu and ngpu are optional arguments and their default value are, respectively, 1 and 0.\n\nInput Arguments :\n\nncpu: number of working threads on CPU.\nngpu: number of working threads on GPU.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_finalize","page":"API","title":"QRMumps.qrm_finalize","text":"qrm_finalize()\n\nThis routine finalizes qr_mumps and no other qr_mumps routine should be called afterwards.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"qrm_spmat_init\nqrm_spmat_init!\nqrm_spmat_destroy!","category":"page"},{"location":"api/#QRMumps.qrm_spmat_init","page":"API","title":"QRMumps.qrm_spmat_init","text":"spmat = qrm_spmat_init(A; sym=false)\nspmat = qrm_spmat_init(m, n, rows, cols, vals; sym=false)\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spmat_init!","page":"API","title":"QRMumps.qrm_spmat_init!","text":"qrm_spmat_init!(spmat, A; sym=false)\nspmat = qrm_spmat_init!(spmat, m, n, rows, cols, vals; sym=false)\n\nThis routine initializes a qrm_spmat type data structure from a sparseMatrixCSC.\n\nInput Arguments :\n\nIn the first form,\n\nspmat: the qrm_spmat sparse matrix to be initialized.\nA : a Julia sparse matrix stored in either SparseMatrixCSC or SparseMatrixCOO format (see SparseMatricesCOO.jl for the second case).\nsym : a boolean to specify if the matrix is symmetric / hermitian (true) or unsymmetric (false).\n\nIn the second form, the matrix A is specified using\n\nm: the number of rows.\nn: the number of columns.\nrows: the array of row indices of nonzero elements.\ncols: the array of column indices of nonzero elements.\nvals: the array of values of nonzero elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spmat_destroy!","page":"API","title":"QRMumps.qrm_spmat_destroy!","text":"qrm_spmat_destroy!(spmat)\n\nThis routine cleans up a qrm_spmat type data structure.\n\nInput Argument :\n\nspfct: the sparse matrix to be destroyed.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"qrm_spfct_init\nqrm_spfct_init!\nqrm_spfct_destroy!","category":"page"},{"location":"api/#QRMumps.qrm_spfct_init","page":"API","title":"QRMumps.qrm_spfct_init","text":"spfct = qrm_spfct_init(spmat)\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spfct_init!","page":"API","title":"QRMumps.qrm_spfct_init!","text":"qrm_spfct_init!(spmat, spfct)\n\nThis routine initializes a qrm_spfct type data structure. This amounts to setting all the control parameters to the default values.\n\nInput Arguments :\n\nspmat: the input matrix of type qrm_spmat.\nspfct: the sparse factorization object to be initialized.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spfct_destroy!","page":"API","title":"QRMumps.qrm_spfct_destroy!","text":"qrm_spfct_destroy!(spfct)\n\nThis routine cleans up a qrm_spfct type data structure by deleting the result of a sparse factorization.\n\nInput Argument :\n\nspfct: the sparse factorization object to be destroyed.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"qrm_analyse\nqrm_analyse!\nqrm_update!\nqrm_factorize!\nqrm_solve\nqrm_solve!\nqrm_apply\nqrm_apply!","category":"page"},{"location":"api/#QRMumps.qrm_analyse","page":"API","title":"QRMumps.qrm_analyse","text":"spfct = qrm_analyse(spmat; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_analyse!","page":"API","title":"QRMumps.qrm_analyse!","text":"qrm_analyse!(spmat, spfct; transp='n')\n\nThis routine performs the analysis phase and updates spfct.\n\nInput Arguments :\n\nspmat: the input matrix of type qrm_spmat.\nspfct: the sparse factorization object of type qrm_spfct.\ntransp: whether the input matrix should be transposed or not. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_update!","page":"API","title":"QRMumps.qrm_update!","text":"qrm_update!(spmat, A)\nqrm_update!(spmat, vals)\n\nThis routine updates a qrm_spmat type data structure from a sparseMatrixCSC. spmat and A must have the same sparsity pattern.\n\nInput Arguments :\n\nIn the first form,\n\nspmat: the qrm_spmat sparse matrix to be updated.\nA : a Julia sparse matrix stored in SparseMatrixCSC format.\n\nIn the second form,\n\nvals: the array of values of nonzero elements of A.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_factorize!","page":"API","title":"QRMumps.qrm_factorize!","text":"qrm_factorize!(spmat, spfct; transp='n')\n\nThis routine performs the factorization phase. It can only be executed if the analysis is already done.\n\nInput Arguments :\n\nspmat: the input matrix of type qrm_spmat.\nspfct: the sparse factorization object of type qrm_spfct.\ntransp: whether the input matrix should be transposed or not. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_solve","page":"API","title":"QRMumps.qrm_solve","text":"x = qrm_solve(spfct, b; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_solve!","page":"API","title":"QRMumps.qrm_solve!","text":"qrm_solve!(spfct, b, x; transp='n')\n\nThis routine solves the triangular system Rx = b or Rᵀx = b. It can only be executed once the factorization is done.\n\nInput Arguments :\n\nspfct: the sparse factorization object resulting from the qrm_factorize! function.\nb: the right-hand side(s).\nx: the solution vector(s).\ntransp: whether to solve for R, Rᵀ or Rᴴ. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_apply","page":"API","title":"QRMumps.qrm_apply","text":"z = qrm_apply(spfct, b; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_apply!","page":"API","title":"QRMumps.qrm_apply!","text":"qrm_apply!(spfct, b; transp='n')\n\nThis routine computes z = Qb, z = Qᵀb or z = Qᴴb in place and overwrites b. It can only be executed once the factorization is done.\n\nInput Arguments :\n\nspfct: the sparse factorization object resulting from the qrm_factorize! function.\nb: the vector(s) to which Q, Qᵀ or Qᴴ is applied.\ntransp: whether to apply Q, Qᵀ or Qᴴ. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"qrm_spfct_get_cp\nqrm_spfct_get_rp\nqrm_spfct_get_r","category":"page"},{"location":"api/#QRMumps.qrm_spfct_get_cp","page":"API","title":"QRMumps.qrm_spfct_get_cp","text":"cp = qrm_spfct_get_cp(spfct)\n\nReturns the column permutation.\n\nInput Arguments :\n\nspfct: a sparse factorization object of type qrm_spfct.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spfct_get_rp","page":"API","title":"QRMumps.qrm_spfct_get_rp","text":"rp = qrm_spfct_get_rp(spfct)\n\nReturns the row permutation.\n\nInput Arguments :\n\nspfct: a sparse factorization object of type qrm_spfct.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spfct_get_r","page":"API","title":"QRMumps.qrm_spfct_get_r","text":"R = qrm_spfct_get_r(spfct)\n\nReturns the R factor as a SparseMatrixCSC matrix.\n\nInput Arguments :\n\nspfct: a sparse factorization object of type qrm_spfct.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"qrm_spbackslash\nqrm_spbackslash!\nqrm_spposv\nqrm_spposv!\nqrm_least_squares\nqrm_least_squares!\nqrm_min_norm\nqrm_min_norm!\nqrm_refine\nqrm_refine!","category":"page"},{"location":"api/#QRMumps.qrm_spbackslash","page":"API","title":"QRMumps.qrm_spbackslash","text":"x = qrm_spbackslash(spmat, b; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spbackslash!","page":"API","title":"QRMumps.qrm_spbackslash!","text":"qrm_spbackslash!(spmat, b, x; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spposv","page":"API","title":"QRMumps.qrm_spposv","text":"x = qrm_spposv(spmat, b)\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spposv!","page":"API","title":"QRMumps.qrm_spposv!","text":"qrm_spposv!(spmat, b, x)\n\nThis function can be used to solve a linear symmetric, positive definite problem. It is a shortcut for the sequence\n\nx = b\nqrm_analyse!(spmat, spfct; transp='n')\nqrm_factorize!(spmat, spfct; transp='n')\nqrm_solve!(spfct, x, x; transp='t')\nqrm_solve!(spfct, x, x; transp='t')\n\nInput Arguments :\n\nspmat: the input matrix.\nb: the right-hand side(s).\nx: the solution vector(s).\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_least_squares","page":"API","title":"QRMumps.qrm_least_squares","text":"x = qrm_least_squares(spmat, b; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_least_squares!","page":"API","title":"QRMumps.qrm_least_squares!","text":"qrm_least_squares!(spmat, b, x; transp='n')\n\nThis function can be used to solve a linear least squares problem\n\nmin Ax  b_2\n\nin the case where the input matrix is square or overdetermined. It is a shortcut for the sequence\n\nqrm_analyse!(spmat, spfct; transp='n')\nqrm_factorize!(spmat, spfct; transp='n')\nqrm_apply!(spfct, b; transp='t')\nqrm_solve!(spfct, b, x; transp='n')\n\nInput Arguments :\n\nspmat: the input matrix.\nb: the ight-hand side(s).\nx: the solution vector(s).\ntransp: whether to use A, Aᵀ or Aᴴ. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_min_norm","page":"API","title":"QRMumps.qrm_min_norm","text":"x = qrm_min_norm(spmat, b; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_min_norm!","page":"API","title":"QRMumps.qrm_min_norm!","text":"qrm_min_norm!(spmat, b, x; transp='n')\n\nThis function can be used to solve a linear minimum norm problem\n\nmin x_2 quad st quad Ax = b\n\nin the case where the input matrix is square or underdetermined. It is a shortcut for the sequence\n\nqrm_analyse!(spmat, spfct; transp='t')\nqrm_factorize!(spmat, spfct; transp='t')\nqrm_solve!(spfct, b, x; transp='t')\nqrm_apply!(spfct, x; transp='n')\n\nInput Arguments :\n\nspmat: the input matrix.\nb: the right-hand side(s).\nx: the solution vector(s).\ntransp: whether to use A, Aᵀ or Aᴴ. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_refine","page":"API","title":"QRMumps.qrm_refine","text":"x_refined = qrm_refine(spmat, spfct, x, z)\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_refine!","page":"API","title":"QRMumps.qrm_refine!","text":"qrm_refine!(spmat, spfct, x, z, Δx, y)\n\nGiven an approximate solution x of the linear system RᵀRx ≈ z where R is the R-factor of some QR factorization of size (m, n), compute a refined solution.\n\nInput Arguments :\n\nspmat: the input matrix.\nspfct: a sparse factorization object of type qrm_spfct.\nx: the approximate solution vector, the size of this vector is n.\nz: the RHS vector of the linear system, the size of this vector is n.\nΔx: an auxiliary vector used to compute the refinement, the size of this vector is n.\ny: an auxiliary vector used to compute the refinement, the size of this vector is m.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"qrm_spmat_mv!\nqrm_spmat_nrm\nqrm_vecnrm!\nqrm_vecnrm\nqrm_residual_norm!\nqrm_residual_norm\nqrm_residual_orth!\nqrm_residual_orth","category":"page"},{"location":"api/#QRMumps.qrm_spmat_mv!","page":"API","title":"QRMumps.qrm_spmat_mv!","text":"qrm_spmat_mv!(spmat, alpha, x, beta, y; transp='n')\n\nThis subroutine performs a matrix-vector product of the type y = αAx + βy, y = αAᵀx + βy or y = αAᴴx + βy.\n\nInput Arguments :\n\nspmat: the input matrix.\nalpha, beta : the α and β scalars\nx: the x vector(s).\ny: the y vector(s).\ntransp: whether to multiply by A, Aᵀ or Aᴴ. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_spmat_nrm","page":"API","title":"QRMumps.qrm_spmat_nrm","text":"qrm_spmat_nrm(spmat; ntype='f')\n\nThis routine computes the one-norm A_1, the infinity-norm x_infty or the two-norm x_2 of a matrix.\n\nInput Arguments :\n\nspmat: the input matrix.\nntype: the type of norm to be computed. It can be either 'i', '1' or 'f' for the infinity, one and Frobenius norms, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_vecnrm!","page":"API","title":"QRMumps.qrm_vecnrm!","text":"qrm_vecnrm!(x, nrm; ntype='2')\n\nThis routine computes the one-norm x_1, the infinity-norm x_infty or the two-norm x_2 of a vector.\n\nInput Arguments :\n\nx: the x vector(s).\nnrm: the computed norm(s). If x is a matrix this argument has to be a vector and each of its elements will contain the norm of the corresponding column of x.\nntype: the type of norm to be computed. It can be either 'i', '1' or '2' for the infinity, one and two norms, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_vecnrm","page":"API","title":"QRMumps.qrm_vecnrm","text":"nrm = qrm_vecnrm(x; ntype='2')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_residual_norm!","page":"API","title":"QRMumps.qrm_residual_norm!","text":"qrm_residual_norm!(spmat, b, x, nrm; transp='n')\n\nThis function computes the scaled norm of the residual fracb - Ax_inftyb_infty + x_infty A_infty, i.e., the normwise backward error.\n\nInput Arguments :\n\nspmat: the input matrix.\nb: the right-hand side(s).\nx: the solution vector(s).\nnrm: the computed norm(s).\ntransp: whether to use A, Aᵀ or Aᴴ. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_residual_norm","page":"API","title":"QRMumps.qrm_residual_norm","text":"nrm = qrm_residual_norm(spmat, b, x; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_residual_orth!","page":"API","title":"QRMumps.qrm_residual_orth!","text":"qrm_residual_orth!(spmat, r, nrm; transp='n')\n\nComputes the quantity fracA^T r_2r_2 which can be used to evaluate the quality of the solution of a least squares problem.\n\nInput Arguments :\n\nspmat: the input matrix.\nr: the residual(s).\nnrm: the computed norm(s).\ntransp: whether to use A, Aᵀ or Aᴴ. Can be either 't', 'c' or 'n'.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_residual_orth","page":"API","title":"QRMumps.qrm_residual_orth","text":"nrm = qrm_residual_orth(spmat, r; transp='n')\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"qrm_set\nqrm_get","category":"page"},{"location":"api/#QRMumps.qrm_set","page":"API","title":"QRMumps.qrm_set","text":"qrm_set(str, val)\nqrm_set(spfct, str, val)\n\nSet control parameters that define the behavior of qr_mumps.\n\nInput Arguments :\n\nspfct: a sparse factorization object of type qrm_spfct.\nstr: a string describing the parameter to set.\nval: the parameter value.\n\n\n\n\n\n","category":"function"},{"location":"api/#QRMumps.qrm_get","page":"API","title":"QRMumps.qrm_get","text":"val = qrm_get(str)\nval = qrm_get(spfct, str)\n\nReturns the value of a control parameter or an information parameter.\n\nInput Arguments :\n\nspfct: a sparse factorization object of type qrm_spfct.\nstr: a string describing the parameter to get.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"experimental/","page":"-","title":"-","text":"qrm_ngpu: integer specifying the number of GPUs to use for the subsequent qr_mumps calls. It is an argument to the qrm_init routine. Default is 0.\nqrm_pinth: an integer value to control memory pinning when GPUs are used: all frontal matrices whose size (min(rows,cols)) is bigger than this value will be pinned.","category":"page"},{"location":"experimental/","page":"-","title":"-","text":"Note that it is possible to use multiple streams per GPU; this can be controlled through the StarPU STARPU_NWORKER_PER_CUDA environment variable.","category":"page"},{"location":"experimental/#**GPU-streams**","page":"-","title":"GPU streams","text":"","category":"section"},{"location":"experimental/","page":"-","title":"-","text":"When GPUs are used, it can be helpful (and it usually is) to use multiple streams per GPU to allow a single GPU to execute multiple tasks concurrently. Using multiple GPU streams is especially beneficial to achieve high GPU occupancy when a relatively small block size mb is chosen to prevent CPU starvation. This can be controlled through the STARPU_NWORKER_PER_CUDA StarPU environment variable. By default one stream is active per GPU device and higher performance can be commonly achieved with values of 2 up to 20.","category":"page"},{"location":"tutorials/ln/","page":"Least-norm problems","title":"Least-norm problems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 5]\njcn = [3, 5, 7, 1, 4, 6, 2, 6, 5, 6, 3, 4, 7]\nval = [2.0, 3.0, 5.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 1.0, 2.0, 2.0]\n\nA = sparse(irn, jcn, val, 5, 7)\nb = [56.0, 21.0, 16.0, 22.0, 25.0]\nx_star = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nx = qrm_min_norm(spmat, b)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/ln/","page":"Least-norm problems","title":"Least-norm problems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 5]\njcn = [3, 5, 7, 1, 4, 6, 2, 6, 5, 6, 3, 4, 7]\nval = [2.0, 3.0, 5.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 1.0, 2.0, 2.0]\n\nA = sparse(irn, jcn, val, 5, 7)\nb = [56.0, 21.0, 16.0, 22.0, 25.0]\nx_star = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct, transp='t')\nqrm_factorize!(spmat, spfct, transp='t')\nz = qrm_solve(spfct, b, transp='t')\nx = qrm_apply(spfct, z)\n\nerror_norm = norm(x - x_star)\nresidual_norm = norm(A * x - b)\n\n@printf(\"Error norm ‖x* - x‖ = %10.5e\\n\", error_norm)\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"tutorials/ln/","page":"Least-norm problems","title":"Least-norm problems","text":"using QRMumps, LinearAlgebra, SparseArrays, Printf\n\nirn = [1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 5]\njcn = [3, 5, 7, 1, 4, 6, 2, 6, 5, 6, 3, 4, 7]\nval = [1.0-im, 2.0+im, 3.0-im, 1.0+im, 1.0-im, 2.0+im, 4.0-im, 1.0+im, 5.0-im, 1.0+im, 3.0-im, 6.0+im, 1.0-im]\n\nA = sparse(irn, jcn, val, 5, 7)\nb = [1.0+im, 2.0+im, 3.0+im, 4.0+im, 5.0+im]\nx = zeros(ComplexF64, 7)\n\nqrm_init()\n\nspmat = qrm_spmat_init(A)\nspfct = qrm_spfct_init(spmat)\n\nqrm_analyse!(spmat, spfct, transp='c')\nqrm_factorize!(spmat, spfct, transp='c')\nqrm_solve!(spfct, b, x, transp='c')\nqrm_apply!(spfct, x)\n\nresidual_norm = norm(A * x - b)\n\n@printf(\"Residual norm ‖Ax - b‖ = %10.5e\\n\", residual_norm)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides a Julia interface to qr_mumps, a software for solving sparse linear systems on multicore computers. qr_mumps implements a direct solution method based on the QR or Cholesky factorization of the input matrix.  Therefore, it is suited to solving sparse least-squares problems, to computing the minimum-norm solution of sparse, underdetermined problems and to solving symmetric, positive-definite sparse linear systems. It can obviously be used for solving square unsymmetric problems in which case the stability provided by the use of orthogonal transformations comes at the cost of a higher operation count with respect to solvers based on, e.g., the LU factorization such as MUMPS. It supports real and complex, single or double precision arithmetic.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As in all the sparse, direct solvers, the solution is achieved in three distinct phases:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Analysis\nIn this phase an analysis of the structural properties of the input matrix is performed in preparation for the numerical factorization phase. This includes computing a column permutation which reduces the amount of fill-in coefficients (i.e., nonzeroes introduced by the factorization). This step does not perform any floating-point operation and is, thus, commonly much faster than the factorization and solve (depending on the number of right-hand sides) phases.\nFactorization\nAt this step, the actual QR or Cholesky factorization is computed. This step is the most computationally intense and, therefore, the most time consuming.\nSolution\nOnce the factorization is done, the factors can be used to compute the solution of the problem through two operations:\nSolve : this operation computes the solution of the triangular system Rx=b or Rᵀx=b;\nApply : this operation applies the Q orthogonal matrix to a vector, i.e., y=Qx or y=Qᵀx. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These three steps have to be done in order but each of them can be performed multiple times. If, for example, the problem has to be solved against multiple right-hand sides (not all available at once), the analysis and factorization can be done only once while the solution is repeated for each right-hand side. By the same token, if the coefficients of a matrix are updated but not its structure, the analysis can be performed only once for multiple factorization and solution steps.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"qr_mumps is based on the multifrontal factorization method. This method was first introduced by Duff and Reid as a method for the factorization of sparse, symmetric linear systems and, since then, has been the object of numerous studies and the method of choice for several, high-performance, software packages such as MUMPS and UMFPACK.","category":"page"},{"location":"optional_features/#Optional-features","page":"Optional features","title":"Optional features","text":"","category":"section"},{"location":"optional_features/","page":"Optional features","title":"Optional features","text":"The following features of the qr_mumps software are currently unavailable in the Julia interface if the package is installed through Yggdrasil. If a custom qr_mumps install is used which has support for the StarPU runtime, these features can be accessed, although they have not been thoroughly tested within Julia.","category":"page"},{"location":"optional_features/#**Multithreading**","page":"Optional features","title":"Multithreading","text":"","category":"section"},{"location":"optional_features/","page":"Optional features","title":"Optional features","text":"qr_mumps is a parallel, multithreaded software based on the StarPU runtime system and it currently supports multicore or, more generally, shared memory multiprocessor computers. qr_mumps does not run on distributed memory (e.g. clusters) parallel computers. Parallelism is achieved through a decomposition of the workload into fine-grained computational tasks which basically correspond to the execution of a BLAS or LAPACK operation on a blocks. It is strongly recommended to use sequential BLAS and LAPACK libraries and let qr_mumps have full control of the parallelism. The granularity of the tasks is controlled by the qrm_mb and qrm_nb parameters which set the block size for partitioning internal data. Smaller values mean more parallelism; however, because this blocking factor is an upper-bound for the granularity of operations (or, more precisely for the granularity of calls to BLAS and LAPACK routines), it is recommended to choose reasonably large values in order to achieve high efficiency.","category":"page"},{"location":"optional_features/#**GPU-acceleration**","page":"Optional features","title":"GPU acceleration","text":"","category":"section"},{"location":"optional_features/","page":"Optional features","title":"Optional features","text":"qr_mumps can leverage the computing power of Nvidia GPU, commonly available on modern super-computing systems, to accelerate the solution of linear systems, especially large size ones. The use of GPUs is achieved through the StarPU runtime.","category":"page"}]
}
