<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QRMumps.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QRMumps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QRMumps.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../features/">Features</a></li><li><a class="tocitem" href="../optional_features/">Optional features</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../control_parameters/">Control parameters</a></li><li><a class="tocitem" href="../information_parameters/">Information parameters</a></li><li><a class="tocitem" href="../performance/">Performance tuning</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/spd/">Symmetric and positive definite linear systems</a></li><li><a class="tocitem" href="../tutorials/ls/">Least-squares problems</a></li><li><a class="tocitem" href="../tutorials/ln/">Least-norm problems</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spmat" href="#QRMumps.qrm_spmat"><code>QRMumps.qrm_spmat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This data type is used to store a sparse matrix in the COO (or coordinate) format through the <code>irn</code>, <code>jcn</code> and <code>val</code> fields containing the row indices, column indices and values, respectively and the <code>m</code>, <code>n</code> and <code>nz</code> containing the number of rows, columns and nonzeros, respectively. qr_mumps uses a Fortran-style 1-based numbering and thus all row indices are expected to be between 1 and m and all the column indices between 1 and n. Duplicate entries are summed during the factorization, out-of-bound entries are ignored. The <code>sym</code> field is used to specify if the matrix is symmetric and positive definite (<code>true</code>) or not (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/wrapper/qr_mumps_common.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spfct" href="#QRMumps.qrm_spfct"><code>QRMumps.qrm_spfct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This type is used to set the parameters that control the behavior of a sparse factorization, to collect information about its execution (number of flops, memory consumpnion etc) and store the result of  the factorization, namely, the factors with all the symbolic information needed to use them in the solve phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/wrapper/qr_mumps_common.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_init" href="#QRMumps.qrm_init"><code>QRMumps.qrm_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_init(ncpu, ngpu)</code></pre><p>This routine initializes qr_mumps and should be called prior to any other qr_mumps routine. This function is automatically called if you use qr_mumps precompiled with Yggdrasil.</p><pre><code class="language-none">qrm_init()</code></pre><p><code>ncpu</code> and <code>ngpu</code> are optional arguments and their default value are, respectively, <code>1</code> and <code>0</code>.</p><p><strong>Input Arguments :</strong></p><ul><li><code>ncpu</code>: number of working threads on CPU.</li><li><code>ngpu</code>: number of working threads on GPU.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L45-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_finalize" href="#QRMumps.qrm_finalize"><code>QRMumps.qrm_finalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_finalize()</code></pre><p>This routine finalizes qr_mumps and no other qr_mumps routine should be called afterwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spmat_init" href="#QRMumps.qrm_spmat_init"><code>QRMumps.qrm_spmat_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spmat = qrm_spmat_init(A; sym=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spmat_init!" href="#QRMumps.qrm_spmat_init!"><code>QRMumps.qrm_spmat_init!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spmat_init!(spmat, A; sym=false)</code></pre><p>This routine initializes a <strong>qrm_spmat</strong> type data structure from a <strong>sparseMatrixCSC</strong>.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the <strong>qrm_spmat</strong> sparse matrix to be initialized.</li><li><code>A</code> : a Julia sparse matrix stored in <strong>SparseMatrixCSC</strong> format.</li><li><code>sym</code> : a boolean to specify if the matrix is symmetric / hermitian (true) or unsymmetric (false).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spmat_destroy!" href="#QRMumps.qrm_spmat_destroy!"><code>QRMumps.qrm_spmat_destroy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spmat_destroy!(spmat)</code></pre><p>This routine cleans up a <strong>qrm_spmat</strong> type data structure.</p><p><strong>Input Argument :</strong></p><ul><li><code>spfct</code>: the sparse matrix to be destroyed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L87-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spfct_init" href="#QRMumps.qrm_spfct_init"><code>QRMumps.qrm_spfct_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spfct = qrm_spfct_init(spmat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L111-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spfct_init!" href="#QRMumps.qrm_spfct_init!"><code>QRMumps.qrm_spfct_init!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spfct_init!(spmat, spfct)</code></pre><p>This routine initializes a <strong>qrm_spfct</strong> type data structure. This amounts to setting all the control parameters to the default values.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix of type <code>qrm_spmat</code>.</li><li><code>spfct</code>: the sparse factorization object to be initialized.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spfct_destroy!" href="#QRMumps.qrm_spfct_destroy!"><code>QRMumps.qrm_spfct_destroy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spfct_destroy!(spfct)</code></pre><p>This routine cleans up a <strong>qrm_spfct</strong> type data structure by deleting the result of a sparse factorization.</p><p><strong>Input Argument :</strong></p><ul><li><code>spfct</code>: the sparse factorization object to be destroyed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L116-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_analyse" href="#QRMumps.qrm_analyse"><code>QRMumps.qrm_analyse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spfct = qrm_analyse(spmat; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L153-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_analyse!" href="#QRMumps.qrm_analyse!"><code>QRMumps.qrm_analyse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_analyse!(spmat, spfct; transp=&#39;n&#39;)</code></pre><p>This routine performs the analysis phase and updates spfct.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix of type <code>qrm_spmat</code>.</li><li><code>spfct</code>: the sparse factorization object of type <code>qrm_spfct</code>.</li><li><code>transp</code>: whether the input matrix should be transposed or not. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_update!" href="#QRMumps.qrm_update!"><code>QRMumps.qrm_update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_update!(spmat, A)</code></pre><p>This routine updates a <strong>qrm_spmat</strong> type data structure from a <strong>sparseMatrixCSC</strong>. <code>spmat</code> and <code>A</code> must have the same sparsity pattern.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the <strong>qrm_spmat</strong> sparse matrix to be updated.</li><li><code>A</code> : a Julia sparse matrix stored in <strong>SparseMatrixCSC</strong> format.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L127-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_factorize!" href="#QRMumps.qrm_factorize!"><code>QRMumps.qrm_factorize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_factorize!(spmat, spfct; transp=&#39;n&#39;)</code></pre><p>This routine performs the factorization phase. It can only be executed if the analysis is already done.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix of type <code>qrm_spmat</code>.</li><li><code>spfct</code>: the sparse factorization object of type <code>qrm_spfct</code>.</li><li><code>transp</code>: whether the input matrix should be transposed or not. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L158-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_solve" href="#QRMumps.qrm_solve"><code>QRMumps.qrm_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = qrm_solve(spfct, b; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L185-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_solve!" href="#QRMumps.qrm_solve!"><code>QRMumps.qrm_solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_solve!(spfct, b, x; transp=&#39;n&#39;)</code></pre><p>This routine solves the triangular system <code>Rx = b</code> or <code>Rᵀx = b</code>. It can only be executed once the factorization is done.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spfct</code>: the sparse factorization object resulting from the qrm_factorize! function.</li><li><code>b</code>: the right-hand side(s).</li><li><code>x</code>: the solution vector(s).</li><li><code>transp</code>: whether to solve for R or Rᵀ. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L171-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_apply" href="#QRMumps.qrm_apply"><code>QRMumps.qrm_apply</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">z = qrm_apply(spfct, b; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L203-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_apply!" href="#QRMumps.qrm_apply!"><code>QRMumps.qrm_apply!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_apply!(spfct, b; transp=&#39;n&#39;)</code></pre><p>This routine computes <code>z = Qb</code> or <code>z = Qᵀb</code> in place and overwrites b. It can only be executed once the factorization is done.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spfct</code>: the sparse factorization object resulting from the qrm_factorize! function.</li><li><code>b</code>: the vector(s) to which Q or Qᵀ is applied.</li><li><code>transp</code>: whether to apply Q or Qᵀ. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L190-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spbackslash" href="#QRMumps.qrm_spbackslash"><code>QRMumps.qrm_spbackslash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = qrm_spbackslash(spmat, b; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L260-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spbackslash!" href="#QRMumps.qrm_spbackslash!"><code>QRMumps.qrm_spbackslash!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spbackslash!(spmat, b, x; transp=&#39;n&#39;)</code></pre><p>TO DO !</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spposv" href="#QRMumps.qrm_spposv"><code>QRMumps.qrm_spposv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = qrm_spposv(spmat, b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L285-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spposv!" href="#QRMumps.qrm_spposv!"><code>QRMumps.qrm_spposv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spposv!(spmat, b, x)</code></pre><p>This function can be used to solve a linear symmetric, positive definite problem. It is a shortcut for the sequence</p><pre><code class="language-none">x = b
qrm_analyse!(spmat, spfct; transp=&#39;n&#39;)
qrm_factorize!(spmat, spfct; transp=&#39;n&#39;)
qrm_solve!(spfct, x, x; transp=&#39;t&#39;)
qrm_solve!(spfct, x, x; transp=&#39;t&#39;)</code></pre><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix.</li><li><code>b</code>: the right-hand side(s).</li><li><code>x</code>: the solution vector(s).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L265-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_least_squares" href="#QRMumps.qrm_least_squares"><code>QRMumps.qrm_least_squares</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = qrm_least_squares(spmat, b; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L316-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_least_squares!" href="#QRMumps.qrm_least_squares!"><code>QRMumps.qrm_least_squares!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_least_squares!(spmat, b, x; transp=&#39;n&#39;)</code></pre><p>This function can be used to solve a linear least squares problem</p><p class="math-container">\[\min \|Ax − b\|_2\]</p><p>in the case where the input matrix is square or overdetermined. It is a shortcut for the sequence</p><pre><code class="language-none">qrm_analyse!(spmat, spfct; transp=&#39;n&#39;)
qrm_factorize!(spmat, spfct; transp=&#39;n&#39;)
qrm_apply!(spfct, b; transp=&#39;t&#39;)
qrm_solve!(spfct, b, x; transp=&#39;n&#39;)</code></pre><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix.</li><li><code>b</code>: the ight-hand side(s).</li><li><code>x</code>: the solution vector(s).</li><li><code>transp</code>: whether to use A or Aᵀ. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L290-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_min_norm" href="#QRMumps.qrm_min_norm"><code>QRMumps.qrm_min_norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x = qrm_min_norm(spmat, b; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L347-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_min_norm!" href="#QRMumps.qrm_min_norm!"><code>QRMumps.qrm_min_norm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_min_norm!(spmat, b, x; transp=&#39;n&#39;)</code></pre><p>This function can be used to solve a linear minimum norm problem</p><p class="math-container">\[\min \|x\|_2 \quad s.t. \quad Ax = b\]</p><p>in the case where the input matrix is square or underdetermined. It is a shortcut for the sequence</p><pre><code class="language-none">qrm_analyse!(spmat, spfct; transp=&#39;t&#39;)
qrm_factorize!(spmat, spfct; transp=&#39;t&#39;)
qrm_solve!(spfct, b, x; transp=&#39;t&#39;)
qrm_apply!(spfct, x; transp=&#39;n&#39;)</code></pre><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix.</li><li><code>b</code>: the right-hand side(s).</li><li><code>x</code>: the solution vector(s).</li><li><code>transp</code>: whether to use A or Aᵀ. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L321-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spmat_mv!" href="#QRMumps.qrm_spmat_mv!"><code>QRMumps.qrm_spmat_mv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spmat_mv!(spmat, alpha, x, beta, y; transp=&#39;n&#39;)</code></pre><p>This subroutine performs a matrix-vector product of the type y = αAx + βy or y = αAᵀx + βy.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix.</li><li><code>alpha</code>, <code>beta</code> : the α and β scalars</li><li><code>x</code>: the x vector(s).</li><li><code>y</code>: the y vector(s).</li><li><code>transp</code>: whether to multiply by A or Aᵀ. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L208-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_spmat_nrm" href="#QRMumps.qrm_spmat_nrm"><code>QRMumps.qrm_spmat_nrm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_spmat_nrm(spmat; ntype=&#39;f&#39;)</code></pre><p>This routine computes the one-norm <span>$\|A\|_1$</span>, the infinity-norm <span>$\|x\|_{\infty}$</span> or the two-norm <span>$\|x\|_2$</span> of a matrix.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix.</li><li><code>ntype</code>: the type of norm to be computed. It can be either <code>&#39;i&#39;</code>, <code>&#39;1&#39;</code> or <code>&#39;f&#39;</code> for the infinity, one and Frobenius norms, respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L223-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_vecnrm!" href="#QRMumps.qrm_vecnrm!"><code>QRMumps.qrm_vecnrm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_vecnrm!(x, nrm; ntype=&#39;2&#39;)</code></pre><p>This routine computes the one-norm <span>$\|x\|_1$</span>, the infinity-norm <span>$\|x\|_{\infty}$</span> or the two-norm <span>$\|x\|_2$</span> of a vector.</p><p><strong>Input Arguments :</strong></p><ul><li><code>x</code>: the x vector(s).</li><li><code>nrm</code>: the computed norm(s). If x is a matrix this argument has to be a vector and each of its elements will contain the norm of the corresponding column of x.</li><li><code>ntype</code>: the type of norm to be computed. It can be either <code>&#39;i&#39;</code>, <code>&#39;1&#39;</code> or <code>&#39;2&#39;</code> for the infinity, one and two norms, respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L235-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_vecnrm" href="#QRMumps.qrm_vecnrm"><code>QRMumps.qrm_vecnrm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrm = qrm_vecnrm(x; ntype=&#39;2&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L248-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_residual_norm!" href="#QRMumps.qrm_residual_norm!"><code>QRMumps.qrm_residual_norm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_residual_norm!(spmat, b, x, nrm; transp=&#39;n&#39;)</code></pre><p>This function computes the scaled norm of the residual <span>$\frac{\|b - Ax\|_{\infty}}{\|b\|_{\infty} + \|x\|_{\infty} \|A\|_{\infty}}$</span>, i.e., the normwise backward error.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix.</li><li><code>b</code>: the right-hand side(s).</li><li><code>x</code>: the solution vector(s).</li><li><code>nrm</code>: the computed norm(s).</li><li><code>transp</code>: whether to use A or Aᵀ. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L352-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_residual_norm" href="#QRMumps.qrm_residual_norm"><code>QRMumps.qrm_residual_norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrm = qrm_residual_norm(spmat, b, x; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L367-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_residual_orth!" href="#QRMumps.qrm_residual_orth!"><code>QRMumps.qrm_residual_orth!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_residual_orth!(spmat, r, nrm; transp=&#39;n&#39;)</code></pre><p>Computes the quantity <span>$\frac{\|A^T r\|_2}{\|r\|_2}$</span> which can be used to evaluate the quality of the solution of a least squares problem.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spmat</code>: the input matrix.</li><li><code>r</code>: the residual(s).</li><li><code>nrm</code>: the computed norm(s).</li><li><code>transp</code>: whether to use A or Aᵀ. Can be either <code>&#39;t&#39;</code>, <code>&#39;c&#39;</code> or <code>&#39;n&#39;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L372-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_residual_orth" href="#QRMumps.qrm_residual_orth"><code>QRMumps.qrm_residual_orth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrm = qrm_residual_orth(spmat, r; transp=&#39;n&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L386-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_set" href="#QRMumps.qrm_set"><code>QRMumps.qrm_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qrm_set(str, val)
qrm_set(spfct, str, val)</code></pre><p>Set control parameters that define the behavior of <code>qr_mumps</code>.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spfct</code>: a sparse factorization object of type <code>qrm_spfct</code>.</li><li><code>str</code>: a string describing the parameter to set.</li><li><code>val</code>: the parameter value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L391-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QRMumps.qrm_get" href="#QRMumps.qrm_get"><code>QRMumps.qrm_get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">val = qrm_get(str)
val = qrm_get(spfct, str)</code></pre><p>Returns the value of a control parameter or an information parameter.</p><p><strong>Input Arguments :</strong></p><ul><li><code>spfct</code>: a sparse factorization object of type <code>qrm_spfct</code>.</li><li><code>str</code>: a string describing the parameter to get.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/QRMumps.jl/blob/19009fc18237f06a0248b78ebc6b3f4711b5f8cf/src/QRMumps.jl#L405-L415">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optional_features/">« Optional features</a><a class="docs-footer-nextpage" href="../control_parameters/">Control parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 1 September 2022 14:23">Thursday 1 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
